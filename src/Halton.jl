module Halton

# using Distributions
using Primes

export HaltonSeq!, HaltonDraws!

"""
    `HaltonSeq!{T<:AbstractFloat}(H::Vector{T}, B::Int; skip::Int=500)`

Replaces `H` with entries from Halton low discrepancy sequence with base `B`.
Elements in `H` take values in the interval (0, 1).
Keyword argument `skip` is the number initial "burn-in" elements to drop.
"""
function HaltonSeq!(H::AbstractArray{<:AbstractFloat}, B::Integer; skip::Integer=500, kwargs...)
  isprime(B) || error("base number not prime")
  H!(H, B, skip)
end

# """
#     `HaltonDraws!{T<:AbstractFloat}(H::Vector{T}, B::Int, [skip::Int=500, distr=Normal()])`

# Replaces `H` with draws from a distribution `Distributions.dist()`.
# Draws are generated by using Halton sequence with base `B` as the quantiles drawn.
# Keyword argument `skip` is the number initial "burn-in" elements to drop.
# """
# function HaltonDraws!(H::AbstractArray, B::Integer; skip::Integer=500, distr = Normal(), kwargs...)
#   HaltonSeq!(H, B, skip=skip)
#   H .= Distributions.quantile.(distr, H)
# end

####

## Algorithm for generating Halton sequences
function H!(H, base::Int, skip::Int)
  
  # Fill H with Halton Sequence based on b
  S = skip + length(H)
  
  # set D to get generated seq >= S
  D = ceil(Int, log(S) / log(base))
  
  # placeholders
  d = zeros(Int, D+1)
  r = zeros(Rational{Int}, D+1)

  # based on algorithm found in https://www.researchgate.net/publication/229173824_Fast_portable_and_reliable_algorithm_for_the_calculation_of_Halton_numbers
  for k in 1:S
    # Kolar & O'Shea (1993) have 0-based indexing
    # they use the index "l" here
    j = 1  
    
    while d[j] == base-1
      d[j] = 0
      j += 1
    end
    
    d[j] += 1
    
    if j >= 2
      r[j-1] = (d[j] + r[j]) // base
    end
    
    if j >= 3
      for i in (j-1) : -1 : 2
        r[i-1] = r[i] // base
      end
    end
    
    if k > skip
      H[k-skip] = (d[1] + r[1]) // base
    end
  
  end
  
  return H
end

end
